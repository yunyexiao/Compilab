# 实验二报告

## 1. 实验目的
制作一个yacc，接受`grammar.txt`中定义的`LR(1)`文法为输入，输出一个名为`syn.cc`的
c++文件，该文件经编译后可以生成一个相应文法的文法分析器。生成的文法分析器接受一个
`input.txt`的token序列作为输入，并输出其规约序列，最终输出该token序列是否符合文法。


## 2. 假设
1. 文法定义在`grammar.txt`中，且只支持LR(1)文法。第一行定义所有终止符（空白符分隔）
，第二行定义所有非终止符（空白符分隔），第三行定义开始符，第四行开始每行定义一个产
生式，且产生式左端与右端必须以空白符分隔，任意两个符号之间也必须以空白符分隔。除了
文件末尾不允许出现空行。整个文法不允许出现'S'。'S'为保留字。

2. 存在python 3以上版本和g++环境

3. token输入在`input.txt`中，只有token的类型，没有token的值。即`input.txt`中只允许
出现文法定义中的终止符。终止符必须两两以空白符分隔。注意括号及其它运算符与其他终止
符也必须以空白符隔开。


## 3. 内容描述

### 3.1 操作方式

#### 3.1.1 半自动化方式
对于未安装make的Windows系统，使用目录下自带的`mymake.cmd`即可自动生成相关`syn.cc`和
`syn.exe`文件，接着运行：

```cmd
> syn input.txt
```

对于其他系统可以使用make命令的环境：使用`make run`后使用`syn input`或`./syn input`
即可。

#### 3.1.2 手动方式

若运行`mymake`命令报错，请检查文法是否符合第二节的Assuption。若仍然报错，请手动按
如下步骤在命令行操作。
1. 使用python 3以上版本运行`yacc.py`脚本

2. 使用g++按c++11标准编译`syn.cc`源文件

3. 运行该目录下的名为`syn`或`syn.exe`的可执行文件，参数为`input.txt`。

### 3.2 文件
* yacc.py: yacc的python脚本，使用python3以上的版本运行。定义了从接受语法输入到生成
LR(1) Parsing Table并输出的所有类和函数。

* sat.cc: 用于生成语法分析器源码的模板。不可修改。

* syn.cc: 由`yacc.py`生成的语法分析器c++源码，使用c++11规范。不可修改。

* grammar.txt: `yacc.py`的输入文件。定义了LR(1)文法的文本文件。

* input.txt: 文法分析器的输入文件，由该文法的非终止符构成的、空白符隔开的序列。

* syn/syn.exe: 最终的可执行的文法分析器。

* mymake.cmd: 为Windows平台写的简单编译脚本。

* Makefile: 为make命令写的编译脚本。

* Report.md: 说明文档。


## 4. 实现方式
1. 读入文法，添加从'S'到用户定义的开始符的产生式并生成相应产生式对象，并计算所有符号
（'S'除外）的First集

2. 根据First集合构造LR(1) Item初始集合

3. 从初始Items集合开始构造Items集合的状态机

4. 利用状态机构造相应LR(1) Parsing Table

5. 填入`sat.cc`模板生成新cpp文件

6. `sat.cc`中根据给定LR(1) Parsing Table来处理输入并输出规约序列和最终结果。


## 5. 数据结构
* Production: 产生式。包含左端符号和右端的符号序列。

* lr1_grammar: LR(1)语法。包含终止符集合，非终止符集合，开始符和产生式集合。同时在构造
时计算所有符号的First集合。

* lr1_item: LR(1)项目。包含产生式，点所在的位置，和最后预测符集合。

* lr1_itemset: LR(1)项目集合。包含诸多LR(1)项目。可以根据给定初始item进行扩展。

* lr1_stm: LR(1)项目集合的GOTO状态机。包含了项目集合之间的转移关系。


## 6. 核心算法

### 6.1 First集合计算
不停地遍历所有产生式(初始产生式除外)，不断进行以下步骤直到遍历完一遍产生式集合后所有
First集合与前一次遍历结果一致，即收敛后停止遍历：

设产生式为A -> abc...
1. 若a为epsilon，添加epsilon到First(A)

2. 若a为终止符，则将其加入First(A)

3. 若a为非终止符，将First(a)加入First(A)，若a不在末尾，对b重复该2，3步的逻辑。

### 6.2 LR(1) Itemset的计算
使用一个未处理的item队列，初始化为当前itemset中所有item。不断重复以下逻辑直到队列为空：

取出队首item，判断点的后面是否为非终止符，若是，去重并添加所有以该符号为左端的产生式到该
itemset集合，将不重复的产生式加入队列。

### 6.3 LR(1) GOTO STM的构造
对该状态机中的所有新itemset，找到可转移的item并构造相应的转移后的itemset，若该itemset
不存在该状态机中，则加入该状态机并将转移也计入状态转换表。


## 7. Use Cases
这里使用的是龙书上P159页例4.45中的文法(4.1)：

```
E -> E + T
E -> T
T -> T * F
T -> F
F -> ( E )
F -> id
```

而输入则是同一个例子中的输入 id * id + id。根据龙书，其规约序列应为：

```
F -> id
T -> F
F -> id
T -> T * F
E -> T
F -> id
T -> F
E -> E + T
acc
```

以下为程序的输出：

```
F -> id
T -> F
F -> id
T -> T * F
E -> T
F -> id
T -> F
E -> E + T
Accepted.
```

可以看出程序产生的规约序列正确且结果也正确。


